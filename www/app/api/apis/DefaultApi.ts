/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  AudioWaveform,
  CreateTranscript,
  DeletionStatus,
  GetTranscript,
  HTTPValidationError,
  PageGetTranscript,
  RtcOffer,
  UpdateTranscript,
} from "../models";
import {
  AudioWaveformFromJSON,
  AudioWaveformToJSON,
  CreateTranscriptFromJSON,
  CreateTranscriptToJSON,
  DeletionStatusFromJSON,
  DeletionStatusToJSON,
  GetTranscriptFromJSON,
  GetTranscriptToJSON,
  HTTPValidationErrorFromJSON,
  HTTPValidationErrorToJSON,
  PageGetTranscriptFromJSON,
  PageGetTranscriptToJSON,
  RtcOfferFromJSON,
  RtcOfferToJSON,
  UpdateTranscriptFromJSON,
  UpdateTranscriptToJSON,
} from "../models";

export interface V1TranscriptDeleteRequest {
  transcriptId: any;
}

export interface V1TranscriptGetRequest {
  transcriptId: any;
}

export interface V1TranscriptGetAudioMp3Request {
  transcriptId: any;
  token?: any;
}

export interface V1TranscriptGetAudioWaveformRequest {
  transcriptId: any;
}

export interface V1TranscriptGetTopicsRequest {
  transcriptId: any;
}

export interface V1TranscriptGetWebsocketEventsRequest {
  transcriptId: any;
}

export interface V1TranscriptRecordWebrtcRequest {
  transcriptId: any;
  rtcOffer: RtcOffer;
}

export interface V1TranscriptUpdateRequest {
  transcriptId: any;
  updateTranscript: UpdateTranscript;
}

export interface V1TranscriptsCreateRequest {
  createTranscript: CreateTranscript;
}

export interface V1TranscriptsListRequest {
  page?: any;
  size?: any;
}

/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {
  /**
   * Endpoint that serves Prometheus metrics.
   * Metrics
   */
  async metricsRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<any>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/metrics`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<any>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Endpoint that serves Prometheus metrics.
   * Metrics
   */
  async metrics(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<any> {
    const response = await this.metricsRaw(initOverrides);
    return await response.value();
  }

  /**
   * Transcript Delete
   */
  async v1TranscriptDeleteRaw(
    requestParameters: V1TranscriptDeleteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<DeletionStatus>> {
    if (
      requestParameters.transcriptId === null ||
      requestParameters.transcriptId === undefined
    ) {
      throw new runtime.RequiredError(
        "transcriptId",
        "Required parameter requestParameters.transcriptId was null or undefined when calling v1TranscriptDelete.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/transcripts/{transcript_id}`.replace(
          `{${"transcript_id"}}`,
          encodeURIComponent(String(requestParameters.transcriptId)),
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      DeletionStatusFromJSON(jsonValue),
    );
  }

  /**
   * Transcript Delete
   */
  async v1TranscriptDelete(
    requestParameters: V1TranscriptDeleteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<DeletionStatus> {
    const response = await this.v1TranscriptDeleteRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Transcript Get
   */
  async v1TranscriptGetRaw(
    requestParameters: V1TranscriptGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<GetTranscript>> {
    if (
      requestParameters.transcriptId === null ||
      requestParameters.transcriptId === undefined
    ) {
      throw new runtime.RequiredError(
        "transcriptId",
        "Required parameter requestParameters.transcriptId was null or undefined when calling v1TranscriptGet.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/transcripts/{transcript_id}`.replace(
          `{${"transcript_id"}}`,
          encodeURIComponent(String(requestParameters.transcriptId)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetTranscriptFromJSON(jsonValue),
    );
  }

  /**
   * Transcript Get
   */
  async v1TranscriptGet(
    requestParameters: V1TranscriptGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<GetTranscript> {
    const response = await this.v1TranscriptGetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Transcript Get Audio Mp3
   */
  async v1TranscriptGetAudioMp3Raw(
    requestParameters: V1TranscriptGetAudioMp3Request,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<any>> {
    if (
      requestParameters.transcriptId === null ||
      requestParameters.transcriptId === undefined
    ) {
      throw new runtime.RequiredError(
        "transcriptId",
        "Required parameter requestParameters.transcriptId was null or undefined when calling v1TranscriptGetAudioMp3.",
      );
    }

    const queryParameters: any = {};

    if (requestParameters.token !== undefined) {
      queryParameters["token"] = requestParameters.token;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/transcripts/{transcript_id}/audio/mp3`.replace(
          `{${"transcript_id"}}`,
          encodeURIComponent(String(requestParameters.transcriptId)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<any>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Transcript Get Audio Mp3
   */
  async v1TranscriptGetAudioMp3(
    requestParameters: V1TranscriptGetAudioMp3Request,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<any> {
    const response = await this.v1TranscriptGetAudioMp3Raw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Transcript Get Audio Waveform
   */
  async v1TranscriptGetAudioWaveformRaw(
    requestParameters: V1TranscriptGetAudioWaveformRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AudioWaveform>> {
    if (
      requestParameters.transcriptId === null ||
      requestParameters.transcriptId === undefined
    ) {
      throw new runtime.RequiredError(
        "transcriptId",
        "Required parameter requestParameters.transcriptId was null or undefined when calling v1TranscriptGetAudioWaveform.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/transcripts/{transcript_id}/audio/waveform`.replace(
          `{${"transcript_id"}}`,
          encodeURIComponent(String(requestParameters.transcriptId)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AudioWaveformFromJSON(jsonValue),
    );
  }

  /**
   * Transcript Get Audio Waveform
   */
  async v1TranscriptGetAudioWaveform(
    requestParameters: V1TranscriptGetAudioWaveformRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AudioWaveform> {
    const response = await this.v1TranscriptGetAudioWaveformRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Transcript Get Topics
   */
  async v1TranscriptGetTopicsRaw(
    requestParameters: V1TranscriptGetTopicsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<any>> {
    if (
      requestParameters.transcriptId === null ||
      requestParameters.transcriptId === undefined
    ) {
      throw new runtime.RequiredError(
        "transcriptId",
        "Required parameter requestParameters.transcriptId was null or undefined when calling v1TranscriptGetTopics.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/transcripts/{transcript_id}/topics`.replace(
          `{${"transcript_id"}}`,
          encodeURIComponent(String(requestParameters.transcriptId)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<any>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Transcript Get Topics
   */
  async v1TranscriptGetTopics(
    requestParameters: V1TranscriptGetTopicsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<any> {
    const response = await this.v1TranscriptGetTopicsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Transcript Get Websocket Events
   */
  async v1TranscriptGetWebsocketEventsRaw(
    requestParameters: V1TranscriptGetWebsocketEventsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<any>> {
    if (
      requestParameters.transcriptId === null ||
      requestParameters.transcriptId === undefined
    ) {
      throw new runtime.RequiredError(
        "transcriptId",
        "Required parameter requestParameters.transcriptId was null or undefined when calling v1TranscriptGetWebsocketEvents.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/v1/transcripts/{transcript_id}/events`.replace(
          `{${"transcript_id"}}`,
          encodeURIComponent(String(requestParameters.transcriptId)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<any>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Transcript Get Websocket Events
   */
  async v1TranscriptGetWebsocketEvents(
    requestParameters: V1TranscriptGetWebsocketEventsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<any> {
    const response = await this.v1TranscriptGetWebsocketEventsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Transcript Record Webrtc
   */
  async v1TranscriptRecordWebrtcRaw(
    requestParameters: V1TranscriptRecordWebrtcRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<any>> {
    if (
      requestParameters.transcriptId === null ||
      requestParameters.transcriptId === undefined
    ) {
      throw new runtime.RequiredError(
        "transcriptId",
        "Required parameter requestParameters.transcriptId was null or undefined when calling v1TranscriptRecordWebrtc.",
      );
    }

    if (
      requestParameters.rtcOffer === null ||
      requestParameters.rtcOffer === undefined
    ) {
      throw new runtime.RequiredError(
        "rtcOffer",
        "Required parameter requestParameters.rtcOffer was null or undefined when calling v1TranscriptRecordWebrtc.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/transcripts/{transcript_id}/record/webrtc`.replace(
          `{${"transcript_id"}}`,
          encodeURIComponent(String(requestParameters.transcriptId)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RtcOfferToJSON(requestParameters.rtcOffer),
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<any>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Transcript Record Webrtc
   */
  async v1TranscriptRecordWebrtc(
    requestParameters: V1TranscriptRecordWebrtcRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<any> {
    const response = await this.v1TranscriptRecordWebrtcRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Transcript Update
   */
  async v1TranscriptUpdateRaw(
    requestParameters: V1TranscriptUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<GetTranscript>> {
    if (
      requestParameters.transcriptId === null ||
      requestParameters.transcriptId === undefined
    ) {
      throw new runtime.RequiredError(
        "transcriptId",
        "Required parameter requestParameters.transcriptId was null or undefined when calling v1TranscriptUpdate.",
      );
    }

    if (
      requestParameters.updateTranscript === null ||
      requestParameters.updateTranscript === undefined
    ) {
      throw new runtime.RequiredError(
        "updateTranscript",
        "Required parameter requestParameters.updateTranscript was null or undefined when calling v1TranscriptUpdate.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/transcripts/{transcript_id}`.replace(
          `{${"transcript_id"}}`,
          encodeURIComponent(String(requestParameters.transcriptId)),
        ),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: UpdateTranscriptToJSON(requestParameters.updateTranscript),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetTranscriptFromJSON(jsonValue),
    );
  }

  /**
   * Transcript Update
   */
  async v1TranscriptUpdate(
    requestParameters: V1TranscriptUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<GetTranscript> {
    const response = await this.v1TranscriptUpdateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Transcripts Create
   */
  async v1TranscriptsCreateRaw(
    requestParameters: V1TranscriptsCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<GetTranscript>> {
    if (
      requestParameters.createTranscript === null ||
      requestParameters.createTranscript === undefined
    ) {
      throw new runtime.RequiredError(
        "createTranscript",
        "Required parameter requestParameters.createTranscript was null or undefined when calling v1TranscriptsCreate.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/transcripts`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateTranscriptToJSON(requestParameters.createTranscript),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GetTranscriptFromJSON(jsonValue),
    );
  }

  /**
   * Transcripts Create
   */
  async v1TranscriptsCreate(
    requestParameters: V1TranscriptsCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<GetTranscript> {
    const response = await this.v1TranscriptsCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Transcripts List
   */
  async v1TranscriptsListRaw(
    requestParameters: V1TranscriptsListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PageGetTranscript>> {
    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters["page"] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters["size"] = requestParameters.size;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/transcripts`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PageGetTranscriptFromJSON(jsonValue),
    );
  }

  /**
   * Transcripts List
   */
  async v1TranscriptsList(
    requestParameters: V1TranscriptsListRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PageGetTranscript> {
    const response = await this.v1TranscriptsListRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * User Me
   */
  async v1UserMeRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<any>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      headerParameters["Authorization"] = await this.configuration.accessToken(
        "OAuth2AuthorizationCodeBearer",
        [],
      );
    }

    const response = await this.request(
      {
        path: `/v1/me`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<any>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * User Me
   */
  async v1UserMe(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<any> {
    const response = await this.v1UserMeRaw(initOverrides);
    return await response.value();
  }
}
